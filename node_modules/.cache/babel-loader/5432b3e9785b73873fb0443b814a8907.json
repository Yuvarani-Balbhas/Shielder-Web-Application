{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asap = asap;\nexports.suspend = suspend;\nexports.flush = flush;\nvar queue = [];\n/**\n  Variable to hold a counting semaphore\n  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not\n    already suspended)\n  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This\n    triggers flushing the queued tasks.\n**/\n\nvar semaphore = 0;\n/**\n  Executes a task 'atomically'. Tasks scheduled during this execution will be queued\n  and flushed after this task has finished (assuming the scheduler endup in a released\n  state).\n**/\n\nfunction exec(task) {\n  try {\n    suspend();\n    task();\n  } finally {\n    flush();\n  }\n}\n/**\n  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)\n**/\n\n\nfunction asap(task) {\n  if (!semaphore) {\n    exec(task);\n  } else {\n    queue.push(task);\n  }\n}\n/**\n  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the\n  scheduler is released.\n**/\n\n\nfunction suspend() {\n  semaphore++;\n}\n/**\n  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.\n**/\n\n\nfunction flush() {\n  semaphore--;\n\n  if (!semaphore && queue.length) {\n    exec(queue.shift());\n  }\n}","map":{"version":3,"sources":["C:/Users/Yuvarani/Desktop/shielder web/node_modules/redux-saga/lib/internal/scheduler.js"],"names":["Object","defineProperty","exports","value","asap","suspend","flush","queue","semaphore","exec","task","push","length","shift"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,IAAR,GAAeA,IAAf;AACAF,OAAO,CAACG,OAAR,GAAkBA,OAAlB;AACAH,OAAO,CAACI,KAAR,GAAgBA,KAAhB;AAEA,IAAIC,KAAK,GAAG,EAAZ;AACA;;;;;;;;AAOA,IAAIC,SAAS,GAAG,CAAhB;AAEA;;;;;;AAKA,SAASC,IAAT,CAAcC,IAAd,EAAoB;AAClB,MAAI;AACFL,IAAAA,OAAO;AACPK,IAAAA,IAAI;AACL,GAHD,SAGU;AACRJ,IAAAA,KAAK;AACN;AACF;AAED;;;;;AAGA,SAASF,IAAT,CAAcM,IAAd,EAAoB;AAClB,MAAI,CAACF,SAAL,EAAgB;AACdC,IAAAA,IAAI,CAACC,IAAD,CAAJ;AACD,GAFD,MAEO;AACLH,IAAAA,KAAK,CAACI,IAAN,CAAWD,IAAX;AACD;AACF;AAED;;;;;;AAIA,SAASL,OAAT,GAAmB;AACjBG,EAAAA,SAAS;AACV;AAED;;;;;AAGA,SAASF,KAAT,GAAiB;AACfE,EAAAA,SAAS;;AACT,MAAI,CAACA,SAAD,IAAcD,KAAK,CAACK,MAAxB,EAAgC;AAC9BH,IAAAA,IAAI,CAACF,KAAK,CAACM,KAAN,EAAD,CAAJ;AACD;AACF","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asap = asap;\nexports.suspend = suspend;\nexports.flush = flush;\n\nvar queue = [];\n/**\n  Variable to hold a counting semaphore\n  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not\n    already suspended)\n  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This\n    triggers flushing the queued tasks.\n**/\nvar semaphore = 0;\n\n/**\n  Executes a task 'atomically'. Tasks scheduled during this execution will be queued\n  and flushed after this task has finished (assuming the scheduler endup in a released\n  state).\n**/\nfunction exec(task) {\n  try {\n    suspend();\n    task();\n  } finally {\n    flush();\n  }\n}\n\n/**\n  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)\n**/\nfunction asap(task) {\n  if (!semaphore) {\n    exec(task);\n  } else {\n    queue.push(task);\n  }\n}\n\n/**\n  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the\n  scheduler is released.\n**/\nfunction suspend() {\n  semaphore++;\n}\n\n/**\n  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.\n**/\nfunction flush() {\n  semaphore--;\n  if (!semaphore && queue.length) {\n    exec(queue.shift());\n  }\n}"]},"metadata":{},"sourceType":"script"}