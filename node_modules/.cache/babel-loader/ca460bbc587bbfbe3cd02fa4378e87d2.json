{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TASK_CANCEL = exports.CHANNEL_END = exports.NOT_ITERATOR_ERROR = undefined;\nexports.default = proc;\n\nvar _utils = require('./utils');\n\nvar _scheduler = require('./scheduler');\n\nvar _io = require('./io');\n\nvar _channel = require('./channel');\n\nvar _buffers = require('./buffers');\n\nfunction _defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar NOT_ITERATOR_ERROR = exports.NOT_ITERATOR_ERROR = 'proc first argument (Saga function result) must be an iterator';\nvar CHANNEL_END = exports.CHANNEL_END = {\n  toString: function toString() {\n    return '@@redux-saga/CHANNEL_END';\n  }\n};\nvar TASK_CANCEL = exports.TASK_CANCEL = {\n  toString: function toString() {\n    return '@@redux-saga/TASK_CANCEL';\n  }\n};\nvar matchers = {\n  wildcard: function wildcard() {\n    return _utils.kTrue;\n  },\n  default: function _default(pattern) {\n    return function (input) {\n      return input.type === String(pattern);\n    };\n  },\n  array: function array(patterns) {\n    return function (input) {\n      return patterns.some(function (p) {\n        return matcher(p)(input);\n      });\n    };\n  },\n  predicate: function predicate(_predicate) {\n    return function (input) {\n      return _predicate(input);\n    };\n  }\n};\n\nfunction matcher(pattern) {\n  return (pattern === '*' ? matchers.wildcard : _utils.is.array(pattern) ? matchers.array : _utils.is.stringableFunc(pattern) ? matchers.default : _utils.is.func(pattern) ? matchers.predicate : matchers.default)(pattern);\n}\n/**\n  Used to track a parent task and its forks\n  In the new fork model, forked tasks are attached by default to their parent\n  We model this using the concept of Parent task && main Task\n  main task is the main flow of the current Generator, the parent tasks is the\n  aggregation of the main tasks + all its forked tasks.\n  Thus the whole model represents an execution tree with multiple branches (vs the\n  linear execution tree in sequential (non parallel) programming)\n\n  A parent tasks has the following semantics\n  - It completes if all its forks either complete or all cancelled\n  - If it's cancelled, all forks are cancelled as well\n  - It aborts if any uncaught error bubbles up from forks\n  - If it completes, the return value is the one returned by the main task\n**/\n\n\nfunction forkQueue(name, mainTask, cb) {\n  var tasks = [],\n      result = void 0,\n      completed = false;\n  addTask(mainTask);\n\n  function abort(err) {\n    cancelAll();\n    cb(err, true);\n  }\n\n  function addTask(task) {\n    tasks.push(task);\n\n    task.cont = function (res, isErr) {\n      if (completed) {\n        return;\n      }\n\n      (0, _utils.remove)(tasks, task);\n      task.cont = _utils.noop;\n\n      if (isErr) {\n        abort(res);\n      } else {\n        if (task === mainTask) {\n          result = res;\n        }\n\n        if (!tasks.length) {\n          completed = true;\n          cb(result);\n        }\n      }\n    }; // task.cont.cancel = task.cancel\n\n  }\n\n  function cancelAll() {\n    if (completed) {\n      return;\n    }\n\n    completed = true;\n    tasks.forEach(function (t) {\n      t.cont = _utils.noop;\n      t.cancel();\n    });\n    tasks = [];\n  }\n\n  return {\n    addTask: addTask,\n    cancelAll: cancelAll,\n    abort: abort,\n    getTasks: function getTasks() {\n      return tasks;\n    },\n    taskNames: function taskNames() {\n      return tasks.map(function (t) {\n        return t.name;\n      });\n    }\n  };\n}\n\nfunction createTaskIterator(_ref) {\n  var context = _ref.context,\n      fn = _ref.fn,\n      args = _ref.args;\n\n  if (_utils.is.iterator(fn)) {\n    return fn;\n  } // catch synchronous failures; see #152 and #441\n\n\n  var result = void 0,\n      error = void 0;\n\n  try {\n    result = fn.apply(context, args);\n  } catch (err) {\n    error = err;\n  } // i.e. a generator function returns an iterator\n\n\n  if (_utils.is.iterator(result)) {\n    return result;\n  } // do not bubble up synchronous failures for detached forks\n  // instead create a failed task. See #152 and #441\n\n\n  return error ? (0, _utils.makeIterator)(function () {\n    throw error;\n  }) : (0, _utils.makeIterator)(function () {\n    var pc = void 0;\n    var eff = {\n      done: false,\n      value: result\n    };\n\n    var ret = function ret(value) {\n      return {\n        done: true,\n        value: value\n      };\n    };\n\n    return function (arg) {\n      if (!pc) {\n        pc = true;\n        return eff;\n      } else {\n        return ret(arg);\n      }\n    };\n  }());\n}\n\nvar wrapHelper = function wrapHelper(helper) {\n  return {\n    fn: helper\n  };\n};\n\nfunction proc(iterator) {\n  var subscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n    return _utils.noop;\n  };\n  var dispatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _utils.noop;\n  var getState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _utils.noop;\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var parentEffectId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var name = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'anonymous';\n  var cont = arguments[7];\n  (0, _utils.check)(iterator, _utils.is.iterator, NOT_ITERATOR_ERROR);\n  var sagaMonitor = options.sagaMonitor,\n      logger = options.logger,\n      onError = options.onError;\n  var log = logger || _utils.log;\n  var stdChannel = (0, _channel.stdChannel)(subscribe);\n  /**\n    Tracks the current effect cancellation\n    Each time the generator progresses. calling runEffect will set a new value\n    on it. It allows propagating cancellation to child effects\n  **/\n\n  next.cancel = _utils.noop;\n  /**\n    Creates a new task descriptor for this generator, We'll also create a main task\n    to track the main flow (besides other forked tasks)\n  **/\n\n  var task = newTask(parentEffectId, name, iterator, cont);\n  var mainTask = {\n    name: name,\n    cancel: cancelMain,\n    isRunning: true\n  };\n  var taskQueue = forkQueue(name, mainTask, end);\n  /**\n    cancellation of the main task. We'll simply resume the Generator with a Cancel\n  **/\n\n  function cancelMain() {\n    if (mainTask.isRunning && !mainTask.isCancelled) {\n      mainTask.isCancelled = true;\n      next(TASK_CANCEL);\n    }\n  }\n  /**\n    This may be called by a parent generator to trigger/propagate cancellation\n    cancel all pending tasks (including the main task), then end the current task.\n     Cancellation propagates down to the whole execution tree holded by this Parent task\n    It's also propagated to all joiners of this task and their execution tree/joiners\n     Cancellation is noop for terminated/Cancelled tasks tasks\n  **/\n\n\n  function cancel() {\n    /**\n      We need to check both Running and Cancelled status\n      Tasks can be Cancelled but still Running\n    **/\n    if (iterator._isRunning && !iterator._isCancelled) {\n      iterator._isCancelled = true;\n      taskQueue.cancelAll();\n      /**\n        Ending with a Never result will propagate the Cancellation to all joiners\n      **/\n\n      end(TASK_CANCEL);\n    }\n  }\n  /**\n    attaches cancellation logic to this task's continuation\n    this will permit cancellation to propagate down the call chain\n  **/\n\n\n  cont && (cont.cancel = cancel); // tracks the running status\n\n  iterator._isRunning = true; // kicks up the generator\n\n  next(); // then return the task descriptor to the caller\n\n  return task;\n  /**\n    This is the generator driver\n    It's a recursive async/continuation function which calls itself\n    until the generator terminates or throws\n  **/\n\n  function next(arg, isErr) {\n    // Preventive measure. If we end up here, then there is really something wrong\n    if (!mainTask.isRunning) {\n      throw new Error('Trying to resume an already finished generator');\n    }\n\n    try {\n      var result = void 0;\n\n      if (isErr) {\n        result = iterator.throw(arg);\n      } else if (arg === TASK_CANCEL) {\n        /**\n          getting TASK_CANCEL automatically cancels the main task\n          We can get this value here\n           - By cancelling the parent task manually\n          - By joining a Cancelled task\n        **/\n        mainTask.isCancelled = true;\n        /**\n          Cancels the current effect; this will propagate the cancellation down to any called tasks\n        **/\n\n        next.cancel();\n        /**\n          If this Generator has a `return` method then invokes it\n          Thill will jump to the finally block\n        **/\n\n        result = _utils.is.func(iterator.return) ? iterator.return(TASK_CANCEL) : {\n          done: true,\n          value: TASK_CANCEL\n        };\n      } else if (arg === CHANNEL_END) {\n        // We get CHANNEL_END by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)\n        result = _utils.is.func(iterator.return) ? iterator.return() : {\n          done: true\n        };\n      } else {\n        result = iterator.next(arg);\n      }\n\n      if (!result.done) {\n        runEffect(result.value, parentEffectId, '', next);\n      } else {\n        /**\n          This Generator has ended, terminate the main task and notify the fork queue\n        **/\n        mainTask.isMainRunning = false;\n        mainTask.cont && mainTask.cont(result.value);\n      }\n    } catch (error) {\n      if (mainTask.isCancelled) {\n        log('error', 'uncaught at ' + name, error.message);\n      }\n\n      mainTask.isMainRunning = false;\n      mainTask.cont(error, true);\n    }\n  }\n\n  function end(result, isErr) {\n    iterator._isRunning = false;\n    stdChannel.close();\n\n    if (!isErr) {\n      if (result === TASK_CANCEL && _utils.isDev) {\n        log('info', name + ' has been cancelled', '');\n      }\n\n      iterator._result = result;\n      iterator._deferredEnd && iterator._deferredEnd.resolve(result);\n    } else {\n      if (result instanceof Error) {\n        result.sagaStack = 'at ' + name + ' \\n ' + (result.sagaStack || result.stack);\n      }\n\n      if (!task.cont) {\n        log('error', 'uncaught', result.sagaStack || result.stack);\n\n        if (result instanceof Error && onError) {\n          onError(result);\n        }\n      }\n\n      iterator._error = result;\n      iterator._isAborted = true;\n      iterator._deferredEnd && iterator._deferredEnd.reject(result);\n    }\n\n    task.cont && task.cont(result, isErr);\n    task.joiners.forEach(function (j) {\n      return j.cb(result, isErr);\n    });\n    task.joiners = null;\n  }\n\n  function runEffect(effect, parentEffectId) {\n    var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var cb = arguments[3];\n    var effectId = (0, _utils.uid)();\n    sagaMonitor && sagaMonitor.effectTriggered({\n      effectId: effectId,\n      parentEffectId: parentEffectId,\n      label: label,\n      effect: effect\n    });\n    /**\n      completion callback and cancel callback are mutually exclusive\n      We can't cancel an already completed effect\n      And We can't complete an already cancelled effectId\n    **/\n\n    var effectSettled = void 0; // Completion callback passed to the appropriate effect runner\n\n    function currCb(res, isErr) {\n      if (effectSettled) {\n        return;\n      }\n\n      effectSettled = true;\n      cb.cancel = _utils.noop; // defensive measure\n\n      if (sagaMonitor) {\n        isErr ? sagaMonitor.effectRejected(effectId, res) : sagaMonitor.effectResolved(effectId, res);\n      }\n\n      cb(res, isErr);\n    } // tracks down the current cancel\n\n\n    currCb.cancel = _utils.noop; // setup cancellation logic on the parent cb\n\n    cb.cancel = function () {\n      // prevents cancelling an already completed effect\n      if (effectSettled) {\n        return;\n      }\n\n      effectSettled = true;\n      /**\n        propagates cancel downward\n        catch uncaught cancellations errors; since we can no longer call the completion\n        callback, log errors raised during cancellations into the console\n      **/\n\n      try {\n        currCb.cancel();\n      } catch (err) {\n        log('error', 'uncaught at ' + name, err.message);\n      }\n\n      currCb.cancel = _utils.noop; // defensive measure\n\n      sagaMonitor && sagaMonitor.effectCancelled(effectId);\n    };\n    /**\n      each effect runner must attach its own logic of cancellation to the provided callback\n      it allows this generator to propagate cancellation downward.\n       ATTENTION! effect runners must setup the cancel logic by setting cb.cancel = [cancelMethod]\n      And the setup must occur before calling the callback\n       This is a sort of inversion of control: called async functions are responsible\n      of completing the flow by calling the provided continuation; while caller functions\n      are responsible for aborting the current flow by calling the attached cancel function\n       Library users can attach their own cancellation logic to promises by defining a\n      promise[CANCEL] method in their returned promises\n      ATTENTION! calling cancel must have no effect on an already completed or cancelled effect\n    **/\n\n\n    var data = void 0;\n    return (// Non declarative effect\n      _utils.is.promise(effect) ? resolvePromise(effect, currCb) : _utils.is.helper(effect) ? runForkEffect(wrapHelper(effect), effectId, currCb) : _utils.is.iterator(effect) ? resolveIterator(effect, effectId, name, currCb) // declarative effects\n      : _utils.is.array(effect) ? runParallelEffect(effect, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.take(effect)) ? runTakeEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.put(effect)) ? runPutEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.race(effect)) ? runRaceEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.call(effect)) ? runCallEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.cps(effect)) ? runCPSEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.fork(effect)) ? runForkEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.join(effect)) ? runJoinEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.cancel(effect)) ? runCancelEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.select(effect)) ? runSelectEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.actionChannel(effect)) ? runChannelEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.flush(effect)) ? runFlushEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.cancelled(effect)) ? runCancelledEffect(data, currCb) :\n      /* anything else returned as is        */\n      currCb(effect)\n    );\n  }\n\n  function resolvePromise(promise, cb) {\n    var cancelPromise = promise[_utils.CANCEL];\n\n    if (typeof cancelPromise === 'function') {\n      cb.cancel = cancelPromise;\n    }\n\n    promise.then(cb, function (error) {\n      return cb(error, true);\n    });\n  }\n\n  function resolveIterator(iterator, effectId, name, cb) {\n    proc(iterator, subscribe, dispatch, getState, options, effectId, name, cb);\n  }\n\n  function runTakeEffect(_ref2, cb) {\n    var channel = _ref2.channel,\n        pattern = _ref2.pattern,\n        maybe = _ref2.maybe;\n    channel = channel || stdChannel;\n\n    var takeCb = function takeCb(inp) {\n      return inp instanceof Error ? cb(inp, true) : (0, _channel.isEnd)(inp) && !maybe ? cb(CHANNEL_END) : cb(inp);\n    };\n\n    try {\n      channel.take(takeCb, matcher(pattern));\n    } catch (err) {\n      return cb(err, true);\n    }\n\n    cb.cancel = takeCb.cancel;\n  }\n\n  function runPutEffect(_ref3, cb) {\n    var channel = _ref3.channel,\n        action = _ref3.action,\n        resolve = _ref3.resolve;\n    /**\n      Schedule the put in case another saga is holding a lock.\n      The put will be executed atomically. ie nested puts will execute after\n      this put has terminated.\n    **/\n\n    (0, _scheduler.asap)(function () {\n      var result = void 0;\n\n      try {\n        result = (channel ? channel.put : dispatch)(action);\n      } catch (error) {\n        // If we have a channel or `put.resolve` was used then bubble up the error.\n        if (channel || resolve) return cb(error, true);\n        log('error', 'uncaught at ' + name, error.stack || error.message || error);\n      }\n\n      if (resolve && _utils.is.promise(result)) {\n        resolvePromise(result, cb);\n      } else {\n        return cb(result);\n      }\n    }); // Put effects are non cancellables\n  }\n\n  function runCallEffect(_ref4, effectId, cb) {\n    var context = _ref4.context,\n        fn = _ref4.fn,\n        args = _ref4.args;\n    var result = void 0; // catch synchronous failures; see #152\n\n    try {\n      result = fn.apply(context, args);\n    } catch (error) {\n      return cb(error, true);\n    }\n\n    return _utils.is.promise(result) ? resolvePromise(result, cb) : _utils.is.iterator(result) ? resolveIterator(result, effectId, fn.name, cb) : cb(result);\n  }\n\n  function runCPSEffect(_ref5, cb) {\n    var context = _ref5.context,\n        fn = _ref5.fn,\n        args = _ref5.args; // CPS (ie node style functions) can define their own cancellation logic\n    // by setting cancel field on the cb\n    // catch synchronous failures; see #152\n\n    try {\n      (function () {\n        var cpsCb = function cpsCb(err, res) {\n          return _utils.is.undef(err) ? cb(res) : cb(err, true);\n        };\n\n        fn.apply(context, args.concat(cpsCb));\n\n        if (cpsCb.cancel) {\n          cb.cancel = function () {\n            return cpsCb.cancel();\n          };\n        }\n      })();\n    } catch (error) {\n      return cb(error, true);\n    }\n  }\n\n  function runForkEffect(_ref6, effectId, cb) {\n    var context = _ref6.context,\n        fn = _ref6.fn,\n        args = _ref6.args,\n        detached = _ref6.detached;\n    var taskIterator = createTaskIterator({\n      context: context,\n      fn: fn,\n      args: args\n    });\n\n    try {\n      (0, _scheduler.suspend)();\n\n      var _task = proc(taskIterator, subscribe, dispatch, getState, options, effectId, fn.name, detached ? null : _utils.noop);\n\n      if (detached) {\n        cb(_task);\n      } else {\n        if (taskIterator._isRunning) {\n          taskQueue.addTask(_task);\n          cb(_task);\n        } else if (taskIterator._error) {\n          taskQueue.abort(taskIterator._error);\n        } else {\n          cb(_task);\n        }\n      }\n    } finally {\n      (0, _scheduler.flush)();\n    } // Fork effects are non cancellables\n\n  }\n\n  function runJoinEffect(t, cb) {\n    if (t.isRunning()) {\n      (function () {\n        var joiner = {\n          task: task,\n          cb: cb\n        };\n\n        cb.cancel = function () {\n          return (0, _utils.remove)(t.joiners, joiner);\n        };\n\n        t.joiners.push(joiner);\n      })();\n    } else {\n      t.isAborted() ? cb(t.error(), true) : cb(t.result());\n    }\n  }\n\n  function runCancelEffect(task, cb) {\n    if (task.isRunning()) {\n      task.cancel();\n    }\n\n    cb(); // cancel effects are non cancellables\n  }\n\n  function runParallelEffect(effects, effectId, cb) {\n    if (!effects.length) {\n      return cb([]);\n    }\n\n    var completedCount = 0;\n    var completed = void 0;\n    var results = Array(effects.length);\n\n    function checkEffectEnd() {\n      if (completedCount === results.length) {\n        completed = true;\n        cb(results);\n      }\n    }\n\n    var childCbs = effects.map(function (eff, idx) {\n      var chCbAtIdx = function chCbAtIdx(res, isErr) {\n        if (completed) {\n          return;\n        }\n\n        if (isErr || (0, _channel.isEnd)(res) || res === CHANNEL_END || res === TASK_CANCEL) {\n          cb.cancel();\n          cb(res, isErr);\n        } else {\n          results[idx] = res;\n          completedCount++;\n          checkEffectEnd();\n        }\n      };\n\n      chCbAtIdx.cancel = _utils.noop;\n      return chCbAtIdx;\n    });\n\n    cb.cancel = function () {\n      if (!completed) {\n        completed = true;\n        childCbs.forEach(function (chCb) {\n          return chCb.cancel();\n        });\n      }\n    };\n\n    effects.forEach(function (eff, idx) {\n      return runEffect(eff, effectId, idx, childCbs[idx]);\n    });\n  }\n\n  function runRaceEffect(effects, effectId, cb) {\n    var completed = void 0;\n    var keys = Object.keys(effects);\n    var childCbs = {};\n    keys.forEach(function (key) {\n      var chCbAtKey = function chCbAtKey(res, isErr) {\n        if (completed) {\n          return;\n        }\n\n        if (isErr) {\n          // Race Auto cancellation\n          cb.cancel();\n          cb(res, true);\n        } else if (!(0, _channel.isEnd)(res) && res !== CHANNEL_END && res !== TASK_CANCEL) {\n          cb.cancel();\n          completed = true;\n          cb(_defineProperty({}, key, res));\n        }\n      };\n\n      chCbAtKey.cancel = _utils.noop;\n      childCbs[key] = chCbAtKey;\n    });\n\n    cb.cancel = function () {\n      // prevents unnecessary cancellation\n      if (!completed) {\n        completed = true;\n        keys.forEach(function (key) {\n          return childCbs[key].cancel();\n        });\n      }\n    };\n\n    keys.forEach(function (key) {\n      if (completed) {\n        return;\n      }\n\n      runEffect(effects[key], effectId, key, childCbs[key]);\n    });\n  }\n\n  function runSelectEffect(_ref7, cb) {\n    var selector = _ref7.selector,\n        args = _ref7.args;\n\n    try {\n      var state = selector.apply(undefined, [getState()].concat(_toConsumableArray(args)));\n      cb(state);\n    } catch (error) {\n      cb(error, true);\n    }\n  }\n\n  function runChannelEffect(_ref8, cb) {\n    var pattern = _ref8.pattern,\n        buffer = _ref8.buffer;\n    var match = matcher(pattern);\n    match.pattern = pattern;\n    cb((0, _channel.eventChannel)(subscribe, buffer || _buffers.buffers.fixed(), match));\n  }\n\n  function runCancelledEffect(data, cb) {\n    cb(!!mainTask.isCancelled);\n  }\n\n  function runFlushEffect(channel, cb) {\n    channel.flush(cb);\n  }\n\n  function newTask(id, name, iterator, cont) {\n    var _done, _ref9, _mutatorMap;\n\n    iterator._deferredEnd = null;\n    return _ref9 = {}, _defineProperty(_ref9, _utils.TASK, true), _defineProperty(_ref9, 'id', id), _defineProperty(_ref9, 'name', name), _done = 'done', _mutatorMap = {}, _mutatorMap[_done] = _mutatorMap[_done] || {}, _mutatorMap[_done].get = function () {\n      if (iterator._deferredEnd) {\n        return iterator._deferredEnd.promise;\n      } else {\n        var def = (0, _utils.deferred)();\n        iterator._deferredEnd = def;\n\n        if (!iterator._isRunning) {\n          iterator._error ? def.reject(iterator._error) : def.resolve(iterator._result);\n        }\n\n        return def.promise;\n      }\n    }, _defineProperty(_ref9, 'cont', cont), _defineProperty(_ref9, 'joiners', []), _defineProperty(_ref9, 'cancel', cancel), _defineProperty(_ref9, 'isRunning', function isRunning() {\n      return iterator._isRunning;\n    }), _defineProperty(_ref9, 'isCancelled', function isCancelled() {\n      return iterator._isCancelled;\n    }), _defineProperty(_ref9, 'isAborted', function isAborted() {\n      return iterator._isAborted;\n    }), _defineProperty(_ref9, 'result', function result() {\n      return iterator._result;\n    }), _defineProperty(_ref9, 'error', function error() {\n      return iterator._error;\n    }), _defineEnumerableProperties(_ref9, _mutatorMap), _ref9;\n  }\n}","map":{"version":3,"sources":["F:/Projects/shielder web/node_modules/redux-saga/lib/internal/proc.js"],"names":["Object","defineProperty","exports","value","TASK_CANCEL","CHANNEL_END","NOT_ITERATOR_ERROR","undefined","default","proc","_utils","require","_scheduler","_io","_channel","_buffers","_defineEnumerableProperties","obj","descs","key","desc","configurable","enumerable","writable","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_defineProperty","toString","matchers","wildcard","kTrue","_default","pattern","input","type","String","array","patterns","some","p","matcher","predicate","_predicate","is","stringableFunc","func","forkQueue","name","mainTask","cb","tasks","result","completed","addTask","abort","err","cancelAll","task","push","cont","res","isErr","remove","noop","forEach","t","cancel","getTasks","taskNames","map","createTaskIterator","_ref","context","fn","args","iterator","error","apply","makeIterator","pc","eff","done","ret","arg","wrapHelper","helper","subscribe","arguments","dispatch","getState","options","parentEffectId","check","sagaMonitor","logger","onError","log","stdChannel","next","newTask","cancelMain","isRunning","taskQueue","end","isCancelled","_isRunning","_isCancelled","Error","throw","return","runEffect","isMainRunning","message","close","isDev","_result","_deferredEnd","resolve","sagaStack","stack","_error","_isAborted","reject","joiners","j","effect","label","effectId","uid","effectTriggered","effectSettled","currCb","effectRejected","effectResolved","effectCancelled","data","promise","resolvePromise","runForkEffect","resolveIterator","runParallelEffect","notUndef","asEffect","take","runTakeEffect","put","runPutEffect","race","runRaceEffect","call","runCallEffect","cps","runCPSEffect","fork","join","runJoinEffect","runCancelEffect","select","runSelectEffect","actionChannel","runChannelEffect","flush","runFlushEffect","cancelled","runCancelledEffect","cancelPromise","CANCEL","then","_ref2","channel","maybe","takeCb","inp","isEnd","_ref3","action","asap","_ref4","_ref5","cpsCb","undef","concat","_ref6","detached","taskIterator","suspend","_task","joiner","isAborted","effects","completedCount","results","checkEffectEnd","childCbs","idx","chCbAtIdx","chCb","keys","chCbAtKey","_ref7","selector","state","_ref8","buffer","match","eventChannel","buffers","fixed","id","_done","_ref9","_mutatorMap","TASK","get","def","deferred"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TASK_CANCEL = exports.CHANNEL_END = exports.NOT_ITERATOR_ERROR = undefined;\nexports.default = proc;\n\nvar _utils = require('./utils');\n\nvar _scheduler = require('./scheduler');\n\nvar _io = require('./io');\n\nvar _channel = require('./channel');\n\nvar _buffers = require('./buffers');\n\nfunction _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if (\"value\" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar NOT_ITERATOR_ERROR = exports.NOT_ITERATOR_ERROR = 'proc first argument (Saga function result) must be an iterator';\n\nvar CHANNEL_END = exports.CHANNEL_END = {\n  toString: function toString() {\n    return '@@redux-saga/CHANNEL_END';\n  }\n};\nvar TASK_CANCEL = exports.TASK_CANCEL = {\n  toString: function toString() {\n    return '@@redux-saga/TASK_CANCEL';\n  }\n};\n\nvar matchers = {\n  wildcard: function wildcard() {\n    return _utils.kTrue;\n  },\n  default: function _default(pattern) {\n    return function (input) {\n      return input.type === String(pattern);\n    };\n  },\n  array: function array(patterns) {\n    return function (input) {\n      return patterns.some(function (p) {\n        return matcher(p)(input);\n      });\n    };\n  },\n  predicate: function predicate(_predicate) {\n    return function (input) {\n      return _predicate(input);\n    };\n  }\n};\n\nfunction matcher(pattern) {\n  return (pattern === '*' ? matchers.wildcard : _utils.is.array(pattern) ? matchers.array : _utils.is.stringableFunc(pattern) ? matchers.default : _utils.is.func(pattern) ? matchers.predicate : matchers.default)(pattern);\n}\n\n/**\n  Used to track a parent task and its forks\n  In the new fork model, forked tasks are attached by default to their parent\n  We model this using the concept of Parent task && main Task\n  main task is the main flow of the current Generator, the parent tasks is the\n  aggregation of the main tasks + all its forked tasks.\n  Thus the whole model represents an execution tree with multiple branches (vs the\n  linear execution tree in sequential (non parallel) programming)\n\n  A parent tasks has the following semantics\n  - It completes if all its forks either complete or all cancelled\n  - If it's cancelled, all forks are cancelled as well\n  - It aborts if any uncaught error bubbles up from forks\n  - If it completes, the return value is the one returned by the main task\n**/\nfunction forkQueue(name, mainTask, cb) {\n  var tasks = [],\n      result = void 0,\n      completed = false;\n  addTask(mainTask);\n\n  function abort(err) {\n    cancelAll();\n    cb(err, true);\n  }\n\n  function addTask(task) {\n    tasks.push(task);\n    task.cont = function (res, isErr) {\n      if (completed) {\n        return;\n      }\n\n      (0, _utils.remove)(tasks, task);\n      task.cont = _utils.noop;\n      if (isErr) {\n        abort(res);\n      } else {\n        if (task === mainTask) {\n          result = res;\n        }\n        if (!tasks.length) {\n          completed = true;\n          cb(result);\n        }\n      }\n    };\n    // task.cont.cancel = task.cancel\n  }\n\n  function cancelAll() {\n    if (completed) {\n      return;\n    }\n    completed = true;\n    tasks.forEach(function (t) {\n      t.cont = _utils.noop;\n      t.cancel();\n    });\n    tasks = [];\n  }\n\n  return {\n    addTask: addTask,\n    cancelAll: cancelAll,\n    abort: abort,\n    getTasks: function getTasks() {\n      return tasks;\n    },\n    taskNames: function taskNames() {\n      return tasks.map(function (t) {\n        return t.name;\n      });\n    }\n  };\n}\n\nfunction createTaskIterator(_ref) {\n  var context = _ref.context,\n      fn = _ref.fn,\n      args = _ref.args;\n\n  if (_utils.is.iterator(fn)) {\n    return fn;\n  }\n\n  // catch synchronous failures; see #152 and #441\n  var result = void 0,\n      error = void 0;\n  try {\n    result = fn.apply(context, args);\n  } catch (err) {\n    error = err;\n  }\n\n  // i.e. a generator function returns an iterator\n  if (_utils.is.iterator(result)) {\n    return result;\n  }\n\n  // do not bubble up synchronous failures for detached forks\n  // instead create a failed task. See #152 and #441\n  return error ? (0, _utils.makeIterator)(function () {\n    throw error;\n  }) : (0, _utils.makeIterator)(function () {\n    var pc = void 0;\n    var eff = { done: false, value: result };\n    var ret = function ret(value) {\n      return { done: true, value: value };\n    };\n    return function (arg) {\n      if (!pc) {\n        pc = true;\n        return eff;\n      } else {\n        return ret(arg);\n      }\n    };\n  }());\n}\n\nvar wrapHelper = function wrapHelper(helper) {\n  return { fn: helper };\n};\n\nfunction proc(iterator) {\n  var subscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n    return _utils.noop;\n  };\n  var dispatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _utils.noop;\n  var getState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _utils.noop;\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var parentEffectId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var name = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'anonymous';\n  var cont = arguments[7];\n\n  (0, _utils.check)(iterator, _utils.is.iterator, NOT_ITERATOR_ERROR);\n\n  var sagaMonitor = options.sagaMonitor,\n      logger = options.logger,\n      onError = options.onError;\n\n  var log = logger || _utils.log;\n  var stdChannel = (0, _channel.stdChannel)(subscribe);\n  /**\n    Tracks the current effect cancellation\n    Each time the generator progresses. calling runEffect will set a new value\n    on it. It allows propagating cancellation to child effects\n  **/\n  next.cancel = _utils.noop;\n\n  /**\n    Creates a new task descriptor for this generator, We'll also create a main task\n    to track the main flow (besides other forked tasks)\n  **/\n  var task = newTask(parentEffectId, name, iterator, cont);\n  var mainTask = { name: name, cancel: cancelMain, isRunning: true };\n  var taskQueue = forkQueue(name, mainTask, end);\n\n  /**\n    cancellation of the main task. We'll simply resume the Generator with a Cancel\n  **/\n  function cancelMain() {\n    if (mainTask.isRunning && !mainTask.isCancelled) {\n      mainTask.isCancelled = true;\n      next(TASK_CANCEL);\n    }\n  }\n\n  /**\n    This may be called by a parent generator to trigger/propagate cancellation\n    cancel all pending tasks (including the main task), then end the current task.\n     Cancellation propagates down to the whole execution tree holded by this Parent task\n    It's also propagated to all joiners of this task and their execution tree/joiners\n     Cancellation is noop for terminated/Cancelled tasks tasks\n  **/\n  function cancel() {\n    /**\n      We need to check both Running and Cancelled status\n      Tasks can be Cancelled but still Running\n    **/\n    if (iterator._isRunning && !iterator._isCancelled) {\n      iterator._isCancelled = true;\n      taskQueue.cancelAll();\n      /**\n        Ending with a Never result will propagate the Cancellation to all joiners\n      **/\n      end(TASK_CANCEL);\n    }\n  }\n  /**\n    attaches cancellation logic to this task's continuation\n    this will permit cancellation to propagate down the call chain\n  **/\n  cont && (cont.cancel = cancel);\n\n  // tracks the running status\n  iterator._isRunning = true;\n\n  // kicks up the generator\n  next();\n\n  // then return the task descriptor to the caller\n  return task;\n\n  /**\n    This is the generator driver\n    It's a recursive async/continuation function which calls itself\n    until the generator terminates or throws\n  **/\n  function next(arg, isErr) {\n    // Preventive measure. If we end up here, then there is really something wrong\n    if (!mainTask.isRunning) {\n      throw new Error('Trying to resume an already finished generator');\n    }\n\n    try {\n      var result = void 0;\n      if (isErr) {\n        result = iterator.throw(arg);\n      } else if (arg === TASK_CANCEL) {\n        /**\n          getting TASK_CANCEL automatically cancels the main task\n          We can get this value here\n           - By cancelling the parent task manually\n          - By joining a Cancelled task\n        **/\n        mainTask.isCancelled = true;\n        /**\n          Cancels the current effect; this will propagate the cancellation down to any called tasks\n        **/\n        next.cancel();\n        /**\n          If this Generator has a `return` method then invokes it\n          Thill will jump to the finally block\n        **/\n        result = _utils.is.func(iterator.return) ? iterator.return(TASK_CANCEL) : { done: true, value: TASK_CANCEL };\n      } else if (arg === CHANNEL_END) {\n        // We get CHANNEL_END by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)\n        result = _utils.is.func(iterator.return) ? iterator.return() : { done: true };\n      } else {\n        result = iterator.next(arg);\n      }\n\n      if (!result.done) {\n        runEffect(result.value, parentEffectId, '', next);\n      } else {\n        /**\n          This Generator has ended, terminate the main task and notify the fork queue\n        **/\n        mainTask.isMainRunning = false;\n        mainTask.cont && mainTask.cont(result.value);\n      }\n    } catch (error) {\n      if (mainTask.isCancelled) {\n        log('error', 'uncaught at ' + name, error.message);\n      }\n      mainTask.isMainRunning = false;\n      mainTask.cont(error, true);\n    }\n  }\n\n  function end(result, isErr) {\n    iterator._isRunning = false;\n    stdChannel.close();\n    if (!isErr) {\n      if (result === TASK_CANCEL && _utils.isDev) {\n        log('info', name + ' has been cancelled', '');\n      }\n      iterator._result = result;\n      iterator._deferredEnd && iterator._deferredEnd.resolve(result);\n    } else {\n      if (result instanceof Error) {\n        result.sagaStack = 'at ' + name + ' \\n ' + (result.sagaStack || result.stack);\n      }\n      if (!task.cont) {\n        log('error', 'uncaught', result.sagaStack || result.stack);\n        if (result instanceof Error && onError) {\n          onError(result);\n        }\n      }\n      iterator._error = result;\n      iterator._isAborted = true;\n      iterator._deferredEnd && iterator._deferredEnd.reject(result);\n    }\n    task.cont && task.cont(result, isErr);\n    task.joiners.forEach(function (j) {\n      return j.cb(result, isErr);\n    });\n    task.joiners = null;\n  }\n\n  function runEffect(effect, parentEffectId) {\n    var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var cb = arguments[3];\n\n    var effectId = (0, _utils.uid)();\n    sagaMonitor && sagaMonitor.effectTriggered({ effectId: effectId, parentEffectId: parentEffectId, label: label, effect: effect });\n\n    /**\n      completion callback and cancel callback are mutually exclusive\n      We can't cancel an already completed effect\n      And We can't complete an already cancelled effectId\n    **/\n    var effectSettled = void 0;\n\n    // Completion callback passed to the appropriate effect runner\n    function currCb(res, isErr) {\n      if (effectSettled) {\n        return;\n      }\n\n      effectSettled = true;\n      cb.cancel = _utils.noop; // defensive measure\n      if (sagaMonitor) {\n        isErr ? sagaMonitor.effectRejected(effectId, res) : sagaMonitor.effectResolved(effectId, res);\n      }\n\n      cb(res, isErr);\n    }\n    // tracks down the current cancel\n    currCb.cancel = _utils.noop;\n\n    // setup cancellation logic on the parent cb\n    cb.cancel = function () {\n      // prevents cancelling an already completed effect\n      if (effectSettled) {\n        return;\n      }\n\n      effectSettled = true;\n      /**\n        propagates cancel downward\n        catch uncaught cancellations errors; since we can no longer call the completion\n        callback, log errors raised during cancellations into the console\n      **/\n      try {\n        currCb.cancel();\n      } catch (err) {\n        log('error', 'uncaught at ' + name, err.message);\n      }\n      currCb.cancel = _utils.noop; // defensive measure\n\n      sagaMonitor && sagaMonitor.effectCancelled(effectId);\n    };\n\n    /**\n      each effect runner must attach its own logic of cancellation to the provided callback\n      it allows this generator to propagate cancellation downward.\n       ATTENTION! effect runners must setup the cancel logic by setting cb.cancel = [cancelMethod]\n      And the setup must occur before calling the callback\n       This is a sort of inversion of control: called async functions are responsible\n      of completing the flow by calling the provided continuation; while caller functions\n      are responsible for aborting the current flow by calling the attached cancel function\n       Library users can attach their own cancellation logic to promises by defining a\n      promise[CANCEL] method in their returned promises\n      ATTENTION! calling cancel must have no effect on an already completed or cancelled effect\n    **/\n    var data = void 0;\n    return (\n      // Non declarative effect\n      _utils.is.promise(effect) ? resolvePromise(effect, currCb) : _utils.is.helper(effect) ? runForkEffect(wrapHelper(effect), effectId, currCb) : _utils.is.iterator(effect) ? resolveIterator(effect, effectId, name, currCb)\n\n      // declarative effects\n      : _utils.is.array(effect) ? runParallelEffect(effect, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.take(effect)) ? runTakeEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.put(effect)) ? runPutEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.race(effect)) ? runRaceEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.call(effect)) ? runCallEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.cps(effect)) ? runCPSEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.fork(effect)) ? runForkEffect(data, effectId, currCb) : _utils.is.notUndef(data = _io.asEffect.join(effect)) ? runJoinEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.cancel(effect)) ? runCancelEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.select(effect)) ? runSelectEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.actionChannel(effect)) ? runChannelEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.flush(effect)) ? runFlushEffect(data, currCb) : _utils.is.notUndef(data = _io.asEffect.cancelled(effect)) ? runCancelledEffect(data, currCb) : /* anything else returned as is        */currCb(effect)\n    );\n  }\n\n  function resolvePromise(promise, cb) {\n    var cancelPromise = promise[_utils.CANCEL];\n    if (typeof cancelPromise === 'function') {\n      cb.cancel = cancelPromise;\n    }\n    promise.then(cb, function (error) {\n      return cb(error, true);\n    });\n  }\n\n  function resolveIterator(iterator, effectId, name, cb) {\n    proc(iterator, subscribe, dispatch, getState, options, effectId, name, cb);\n  }\n\n  function runTakeEffect(_ref2, cb) {\n    var channel = _ref2.channel,\n        pattern = _ref2.pattern,\n        maybe = _ref2.maybe;\n\n    channel = channel || stdChannel;\n    var takeCb = function takeCb(inp) {\n      return inp instanceof Error ? cb(inp, true) : (0, _channel.isEnd)(inp) && !maybe ? cb(CHANNEL_END) : cb(inp);\n    };\n    try {\n      channel.take(takeCb, matcher(pattern));\n    } catch (err) {\n      return cb(err, true);\n    }\n    cb.cancel = takeCb.cancel;\n  }\n\n  function runPutEffect(_ref3, cb) {\n    var channel = _ref3.channel,\n        action = _ref3.action,\n        resolve = _ref3.resolve;\n\n    /**\n      Schedule the put in case another saga is holding a lock.\n      The put will be executed atomically. ie nested puts will execute after\n      this put has terminated.\n    **/\n    (0, _scheduler.asap)(function () {\n      var result = void 0;\n      try {\n        result = (channel ? channel.put : dispatch)(action);\n      } catch (error) {\n        // If we have a channel or `put.resolve` was used then bubble up the error.\n        if (channel || resolve) return cb(error, true);\n        log('error', 'uncaught at ' + name, error.stack || error.message || error);\n      }\n\n      if (resolve && _utils.is.promise(result)) {\n        resolvePromise(result, cb);\n      } else {\n        return cb(result);\n      }\n    });\n    // Put effects are non cancellables\n  }\n\n  function runCallEffect(_ref4, effectId, cb) {\n    var context = _ref4.context,\n        fn = _ref4.fn,\n        args = _ref4.args;\n\n    var result = void 0;\n    // catch synchronous failures; see #152\n    try {\n      result = fn.apply(context, args);\n    } catch (error) {\n      return cb(error, true);\n    }\n    return _utils.is.promise(result) ? resolvePromise(result, cb) : _utils.is.iterator(result) ? resolveIterator(result, effectId, fn.name, cb) : cb(result);\n  }\n\n  function runCPSEffect(_ref5, cb) {\n    var context = _ref5.context,\n        fn = _ref5.fn,\n        args = _ref5.args;\n\n    // CPS (ie node style functions) can define their own cancellation logic\n    // by setting cancel field on the cb\n\n    // catch synchronous failures; see #152\n    try {\n      (function () {\n        var cpsCb = function cpsCb(err, res) {\n          return _utils.is.undef(err) ? cb(res) : cb(err, true);\n        };\n        fn.apply(context, args.concat(cpsCb));\n        if (cpsCb.cancel) {\n          cb.cancel = function () {\n            return cpsCb.cancel();\n          };\n        }\n      })();\n    } catch (error) {\n      return cb(error, true);\n    }\n  }\n\n  function runForkEffect(_ref6, effectId, cb) {\n    var context = _ref6.context,\n        fn = _ref6.fn,\n        args = _ref6.args,\n        detached = _ref6.detached;\n\n    var taskIterator = createTaskIterator({ context: context, fn: fn, args: args });\n\n    try {\n      (0, _scheduler.suspend)();\n      var _task = proc(taskIterator, subscribe, dispatch, getState, options, effectId, fn.name, detached ? null : _utils.noop);\n\n      if (detached) {\n        cb(_task);\n      } else {\n        if (taskIterator._isRunning) {\n          taskQueue.addTask(_task);\n          cb(_task);\n        } else if (taskIterator._error) {\n          taskQueue.abort(taskIterator._error);\n        } else {\n          cb(_task);\n        }\n      }\n    } finally {\n      (0, _scheduler.flush)();\n    }\n    // Fork effects are non cancellables\n  }\n\n  function runJoinEffect(t, cb) {\n    if (t.isRunning()) {\n      (function () {\n        var joiner = { task: task, cb: cb };\n        cb.cancel = function () {\n          return (0, _utils.remove)(t.joiners, joiner);\n        };\n        t.joiners.push(joiner);\n      })();\n    } else {\n      t.isAborted() ? cb(t.error(), true) : cb(t.result());\n    }\n  }\n\n  function runCancelEffect(task, cb) {\n    if (task.isRunning()) {\n      task.cancel();\n    }\n    cb();\n    // cancel effects are non cancellables\n  }\n\n  function runParallelEffect(effects, effectId, cb) {\n    if (!effects.length) {\n      return cb([]);\n    }\n\n    var completedCount = 0;\n    var completed = void 0;\n    var results = Array(effects.length);\n\n    function checkEffectEnd() {\n      if (completedCount === results.length) {\n        completed = true;\n        cb(results);\n      }\n    }\n\n    var childCbs = effects.map(function (eff, idx) {\n      var chCbAtIdx = function chCbAtIdx(res, isErr) {\n        if (completed) {\n          return;\n        }\n        if (isErr || (0, _channel.isEnd)(res) || res === CHANNEL_END || res === TASK_CANCEL) {\n          cb.cancel();\n          cb(res, isErr);\n        } else {\n          results[idx] = res;\n          completedCount++;\n          checkEffectEnd();\n        }\n      };\n      chCbAtIdx.cancel = _utils.noop;\n      return chCbAtIdx;\n    });\n\n    cb.cancel = function () {\n      if (!completed) {\n        completed = true;\n        childCbs.forEach(function (chCb) {\n          return chCb.cancel();\n        });\n      }\n    };\n\n    effects.forEach(function (eff, idx) {\n      return runEffect(eff, effectId, idx, childCbs[idx]);\n    });\n  }\n\n  function runRaceEffect(effects, effectId, cb) {\n    var completed = void 0;\n    var keys = Object.keys(effects);\n    var childCbs = {};\n\n    keys.forEach(function (key) {\n      var chCbAtKey = function chCbAtKey(res, isErr) {\n        if (completed) {\n          return;\n        }\n\n        if (isErr) {\n          // Race Auto cancellation\n          cb.cancel();\n          cb(res, true);\n        } else if (!(0, _channel.isEnd)(res) && res !== CHANNEL_END && res !== TASK_CANCEL) {\n          cb.cancel();\n          completed = true;\n          cb(_defineProperty({}, key, res));\n        }\n      };\n      chCbAtKey.cancel = _utils.noop;\n      childCbs[key] = chCbAtKey;\n    });\n\n    cb.cancel = function () {\n      // prevents unnecessary cancellation\n      if (!completed) {\n        completed = true;\n        keys.forEach(function (key) {\n          return childCbs[key].cancel();\n        });\n      }\n    };\n    keys.forEach(function (key) {\n      if (completed) {\n        return;\n      }\n      runEffect(effects[key], effectId, key, childCbs[key]);\n    });\n  }\n\n  function runSelectEffect(_ref7, cb) {\n    var selector = _ref7.selector,\n        args = _ref7.args;\n\n    try {\n      var state = selector.apply(undefined, [getState()].concat(_toConsumableArray(args)));\n      cb(state);\n    } catch (error) {\n      cb(error, true);\n    }\n  }\n\n  function runChannelEffect(_ref8, cb) {\n    var pattern = _ref8.pattern,\n        buffer = _ref8.buffer;\n\n    var match = matcher(pattern);\n    match.pattern = pattern;\n    cb((0, _channel.eventChannel)(subscribe, buffer || _buffers.buffers.fixed(), match));\n  }\n\n  function runCancelledEffect(data, cb) {\n    cb(!!mainTask.isCancelled);\n  }\n\n  function runFlushEffect(channel, cb) {\n    channel.flush(cb);\n  }\n\n  function newTask(id, name, iterator, cont) {\n    var _done, _ref9, _mutatorMap;\n\n    iterator._deferredEnd = null;\n    return _ref9 = {}, _defineProperty(_ref9, _utils.TASK, true), _defineProperty(_ref9, 'id', id), _defineProperty(_ref9, 'name', name), _done = 'done', _mutatorMap = {}, _mutatorMap[_done] = _mutatorMap[_done] || {}, _mutatorMap[_done].get = function () {\n      if (iterator._deferredEnd) {\n        return iterator._deferredEnd.promise;\n      } else {\n        var def = (0, _utils.deferred)();\n        iterator._deferredEnd = def;\n        if (!iterator._isRunning) {\n          iterator._error ? def.reject(iterator._error) : def.resolve(iterator._result);\n        }\n        return def.promise;\n      }\n    }, _defineProperty(_ref9, 'cont', cont), _defineProperty(_ref9, 'joiners', []), _defineProperty(_ref9, 'cancel', cancel), _defineProperty(_ref9, 'isRunning', function isRunning() {\n      return iterator._isRunning;\n    }), _defineProperty(_ref9, 'isCancelled', function isCancelled() {\n      return iterator._isCancelled;\n    }), _defineProperty(_ref9, 'isAborted', function isAborted() {\n      return iterator._isAborted;\n    }), _defineProperty(_ref9, 'result', function result() {\n      return iterator._result;\n    }), _defineProperty(_ref9, 'error', function error() {\n      return iterator._error;\n    }), _defineEnumerableProperties(_ref9, _mutatorMap), _ref9;\n  }\n}"]},"metadata":{},"sourceType":"script"}