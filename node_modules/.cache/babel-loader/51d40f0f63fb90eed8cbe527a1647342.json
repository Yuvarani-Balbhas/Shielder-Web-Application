{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UNDEFINED_INPUT_ERROR = exports.INVALID_BUFFER = exports.isEnd = exports.END = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.emitter = emitter;\nexports.channel = channel;\nexports.eventChannel = eventChannel;\nexports.stdChannel = stdChannel;\n\nvar _utils = require('./utils');\n\nvar _buffers = require('./buffers');\n\nvar _scheduler = require('./scheduler');\n\nvar CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';\nvar END = exports.END = {\n  type: CHANNEL_END_TYPE\n};\n\nvar isEnd = exports.isEnd = function isEnd(a) {\n  return a && a.type === CHANNEL_END_TYPE;\n};\n\nfunction emitter() {\n  var subscribers = [];\n\n  function subscribe(sub) {\n    subscribers.push(sub);\n    return function () {\n      return (0, _utils.remove)(subscribers, sub);\n    };\n  }\n\n  function emit(item) {\n    var arr = subscribers.slice();\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      arr[i](item);\n    }\n  }\n\n  return {\n    subscribe: subscribe,\n    emit: emit\n  };\n}\n\nvar INVALID_BUFFER = exports.INVALID_BUFFER = 'invalid buffer passed to channel factory function';\nvar UNDEFINED_INPUT_ERROR = exports.UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';\n\nif (process.env.NODE_ENV !== 'production') {\n  exports.UNDEFINED_INPUT_ERROR = UNDEFINED_INPUT_ERROR += '\\nHints:\\n    - check that your Action Creator returns a non-undefined value\\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\\n  ';\n}\n\nfunction channel() {\n  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _buffers.buffers.fixed();\n  var closed = false;\n  var takers = [];\n  (0, _utils.check)(buffer, _utils.is.buffer, INVALID_BUFFER);\n\n  function checkForbiddenStates() {\n    if (closed && takers.length) {\n      throw (0, _utils.internalErr)('Cannot have a closed channel with pending takers');\n    }\n\n    if (takers.length && !buffer.isEmpty()) {\n      throw (0, _utils.internalErr)('Cannot have pending takers with non empty buffer');\n    }\n  }\n\n  function put(input) {\n    checkForbiddenStates();\n    (0, _utils.check)(input, _utils.is.notUndef, UNDEFINED_INPUT_ERROR);\n\n    if (closed) {\n      return;\n    }\n\n    if (!takers.length) {\n      return buffer.put(input);\n    }\n\n    for (var i = 0; i < takers.length; i++) {\n      var cb = takers[i];\n\n      if (!cb[_utils.MATCH] || cb[_utils.MATCH](input)) {\n        takers.splice(i, 1);\n        return cb(input);\n      }\n    }\n  }\n\n  function take(cb) {\n    checkForbiddenStates();\n    (0, _utils.check)(cb, _utils.is.func, 'channel.take\\'s callback must be a function');\n\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n    } else if (!buffer.isEmpty()) {\n      cb(buffer.take());\n    } else {\n      takers.push(cb);\n\n      cb.cancel = function () {\n        return (0, _utils.remove)(takers, cb);\n      };\n    }\n  }\n\n  function flush(cb) {\n    checkForbiddenStates(); // TODO: check if some new state should be forbidden now\n\n    (0, _utils.check)(cb, _utils.is.func, 'channel.flush\\' callback must be a function');\n\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n      return;\n    }\n\n    cb(buffer.flush());\n  }\n\n  function close() {\n    checkForbiddenStates();\n\n    if (!closed) {\n      closed = true;\n\n      if (takers.length) {\n        var arr = takers;\n        takers = [];\n\n        for (var i = 0, len = arr.length; i < len; i++) {\n          arr[i](END);\n        }\n      }\n    }\n  }\n\n  return {\n    take: take,\n    put: put,\n    flush: flush,\n    close: close,\n\n    get __takers__() {\n      return takers;\n    },\n\n    get __closed__() {\n      return closed;\n    }\n\n  };\n}\n\nfunction eventChannel(subscribe) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _buffers.buffers.none();\n  var matcher = arguments[2];\n  /**\n    should be if(typeof matcher !== undefined) instead?\n    see PR #273 for a background discussion\n  **/\n\n  if (arguments.length > 2) {\n    (0, _utils.check)(matcher, _utils.is.func, 'Invalid match function passed to eventChannel');\n  }\n\n  var chan = channel(buffer);\n  var unsubscribe = subscribe(function (input) {\n    if (isEnd(input)) {\n      chan.close();\n      return;\n    }\n\n    if (matcher && !matcher(input)) {\n      return;\n    }\n\n    chan.put(input);\n  });\n\n  if (!_utils.is.func(unsubscribe)) {\n    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');\n  }\n\n  return {\n    take: chan.take,\n    flush: chan.flush,\n    close: function close() {\n      if (!chan.__closed__) {\n        chan.close();\n        unsubscribe();\n      }\n    }\n  };\n}\n\nfunction stdChannel(subscribe) {\n  var chan = eventChannel(function (cb) {\n    return subscribe(function (input) {\n      if (input[_utils.SAGA_ACTION]) {\n        cb(input);\n        return;\n      }\n\n      (0, _scheduler.asap)(function () {\n        return cb(input);\n      });\n    });\n  });\n  return _extends({}, chan, {\n    take: function take(cb, matcher) {\n      if (arguments.length > 1) {\n        (0, _utils.check)(matcher, _utils.is.func, 'channel.take\\'s matcher argument must be a function');\n        cb[_utils.MATCH] = matcher;\n      }\n\n      chan.take(cb);\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/Yuvarani/Desktop/shielder web/node_modules/redux-saga/lib/internal/channel.js"],"names":["Object","defineProperty","exports","value","UNDEFINED_INPUT_ERROR","INVALID_BUFFER","isEnd","END","undefined","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","emitter","channel","eventChannel","stdChannel","_utils","require","_buffers","_scheduler","CHANNEL_END_TYPE","type","a","subscribers","subscribe","sub","push","remove","emit","item","arr","slice","len","process","env","NODE_ENV","buffer","buffers","fixed","closed","takers","check","is","checkForbiddenStates","internalErr","isEmpty","put","input","notUndef","cb","MATCH","splice","take","func","cancel","flush","close","__takers__","__closed__","none","matcher","chan","unsubscribe","Error","SAGA_ACTION","asap"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UNDEFINED_INPUT_ERROR = exports.INVALID_BUFFER = exports.isEnd = exports.END = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.emitter = emitter;\nexports.channel = channel;\nexports.eventChannel = eventChannel;\nexports.stdChannel = stdChannel;\n\nvar _utils = require('./utils');\n\nvar _buffers = require('./buffers');\n\nvar _scheduler = require('./scheduler');\n\nvar CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';\nvar END = exports.END = { type: CHANNEL_END_TYPE };\nvar isEnd = exports.isEnd = function isEnd(a) {\n  return a && a.type === CHANNEL_END_TYPE;\n};\n\nfunction emitter() {\n  var subscribers = [];\n\n  function subscribe(sub) {\n    subscribers.push(sub);\n    return function () {\n      return (0, _utils.remove)(subscribers, sub);\n    };\n  }\n\n  function emit(item) {\n    var arr = subscribers.slice();\n    for (var i = 0, len = arr.length; i < len; i++) {\n      arr[i](item);\n    }\n  }\n\n  return {\n    subscribe: subscribe,\n    emit: emit\n  };\n}\n\nvar INVALID_BUFFER = exports.INVALID_BUFFER = 'invalid buffer passed to channel factory function';\nvar UNDEFINED_INPUT_ERROR = exports.UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';\n\nif (process.env.NODE_ENV !== 'production') {\n  exports.UNDEFINED_INPUT_ERROR = UNDEFINED_INPUT_ERROR += '\\nHints:\\n    - check that your Action Creator returns a non-undefined value\\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\\n  ';\n}\n\nfunction channel() {\n  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _buffers.buffers.fixed();\n\n  var closed = false;\n  var takers = [];\n\n  (0, _utils.check)(buffer, _utils.is.buffer, INVALID_BUFFER);\n\n  function checkForbiddenStates() {\n    if (closed && takers.length) {\n      throw (0, _utils.internalErr)('Cannot have a closed channel with pending takers');\n    }\n    if (takers.length && !buffer.isEmpty()) {\n      throw (0, _utils.internalErr)('Cannot have pending takers with non empty buffer');\n    }\n  }\n\n  function put(input) {\n    checkForbiddenStates();\n    (0, _utils.check)(input, _utils.is.notUndef, UNDEFINED_INPUT_ERROR);\n    if (closed) {\n      return;\n    }\n    if (!takers.length) {\n      return buffer.put(input);\n    }\n    for (var i = 0; i < takers.length; i++) {\n      var cb = takers[i];\n      if (!cb[_utils.MATCH] || cb[_utils.MATCH](input)) {\n        takers.splice(i, 1);\n        return cb(input);\n      }\n    }\n  }\n\n  function take(cb) {\n    checkForbiddenStates();\n    (0, _utils.check)(cb, _utils.is.func, 'channel.take\\'s callback must be a function');\n\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n    } else if (!buffer.isEmpty()) {\n      cb(buffer.take());\n    } else {\n      takers.push(cb);\n      cb.cancel = function () {\n        return (0, _utils.remove)(takers, cb);\n      };\n    }\n  }\n\n  function flush(cb) {\n    checkForbiddenStates(); // TODO: check if some new state should be forbidden now\n    (0, _utils.check)(cb, _utils.is.func, 'channel.flush\\' callback must be a function');\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n      return;\n    }\n    cb(buffer.flush());\n  }\n\n  function close() {\n    checkForbiddenStates();\n    if (!closed) {\n      closed = true;\n      if (takers.length) {\n        var arr = takers;\n        takers = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n          arr[i](END);\n        }\n      }\n    }\n  }\n\n  return { take: take, put: put, flush: flush, close: close,\n    get __takers__() {\n      return takers;\n    },\n    get __closed__() {\n      return closed;\n    }\n  };\n}\n\nfunction eventChannel(subscribe) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _buffers.buffers.none();\n  var matcher = arguments[2];\n\n  /**\n    should be if(typeof matcher !== undefined) instead?\n    see PR #273 for a background discussion\n  **/\n  if (arguments.length > 2) {\n    (0, _utils.check)(matcher, _utils.is.func, 'Invalid match function passed to eventChannel');\n  }\n\n  var chan = channel(buffer);\n  var unsubscribe = subscribe(function (input) {\n    if (isEnd(input)) {\n      chan.close();\n      return;\n    }\n    if (matcher && !matcher(input)) {\n      return;\n    }\n    chan.put(input);\n  });\n\n  if (!_utils.is.func(unsubscribe)) {\n    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');\n  }\n\n  return {\n    take: chan.take,\n    flush: chan.flush,\n    close: function close() {\n      if (!chan.__closed__) {\n        chan.close();\n        unsubscribe();\n      }\n    }\n  };\n}\n\nfunction stdChannel(subscribe) {\n  var chan = eventChannel(function (cb) {\n    return subscribe(function (input) {\n      if (input[_utils.SAGA_ACTION]) {\n        cb(input);\n        return;\n      }\n      (0, _scheduler.asap)(function () {\n        return cb(input);\n      });\n    });\n  });\n\n  return _extends({}, chan, {\n    take: function take(cb, matcher) {\n      if (arguments.length > 1) {\n        (0, _utils.check)(matcher, _utils.is.func, 'channel.take\\'s matcher argument must be a function');\n        cb[_utils.MATCH] = matcher;\n      }\n      chan.take(cb);\n    }\n  });\n}"]},"metadata":{},"sourceType":"script"}